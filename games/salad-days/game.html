<head>
  <script type="text/javascript">
    SaladDaze = (() => {
      // -- "imports" --
      const {
        min,
        pow,
        round: rnd,
        floor: flr,
        random: rand,
      } = Math

      // -- types --
      const Types = {
        Empty: 0,
        Text: 1,
        Sprite: 2,
      }

      // -- bootstrap --
      function Start(id) {
        initAssets(document.getElementById("assets"))
        initWorld()
        initDraw(document.getElementById(id))
        initLoop()
      }

      // -- loop --
      const kFramerate = 30
      const kFrameInterval = 1000.0 / kFramerate
      let mFrame = 1

      function initLoop() {
        setInterval(loop, kFrameInterval)
      }

      // -- l/commands
      function loop() {
        update()
        draw()
        mFrame += 1
      }

      // -- assets --
      let mAssets

      function initAssets(el) {
        // aggregate assets
        mAssets = {}
        for (const asset of el.children) {
          mAssets[asset.id] = asset
        }
      }

      // -- world --
      const kSize = { x: 512, y: 512 }
      const kNumTeeth = 16

      let mObjects

      function initWorld() {
        mObjects = []

        // add infinite salad
        const salad = makeSalad()
        spawn(salad)

        // add teeth
        const teeth = []
        for (let i = 0; i < kNumTeeth; i++) {
          const tooth = makeTooth(i)
          teeth.push(tooth)
          spawn(tooth)
        }

        // add mouth trigger from teeth
        spawn(makeMouth(salad, teeth))
      }

      // -- w/commands
      function update() {
        for (const obj of mObjects) {
          if (obj.update != null) {
            obj.update()
          }
        }
      }

      function spawn(obj) {
        mObjects.push(obj)
      }

      // -- w/game
      function makeSalad() {
        const text = "FREESALADFREESALAD"
        const size = 240.0

        // measure height to loop text
        const h = text.length * size
        const h2 = h / 2.0

        return makeText(text, {
          size,
          down: true,
          skip: [],
          x: (kSize.x - 170.0) / 2,
          y: (kSize.y + size),
          z: 1,
          hide(index) {
            if (this.skip.includes(index)) {
              return
            }

            this.skip.push(index)
          },
          update() {
            // animate text up
            this.y -= 0.8 * kFrameInterval

            // loop text once we're below the repeat
            if (this.y < -h2) {
              this.y += h2
              this.skip = []
            }
          }
        })
      }

      function makeMouth(salad, teeth) {
        // aggregate trigger rect
        let x0 = Number.MAX_VALUE
        let y0 = Number.MAX_VALUE
        let x1 = 0.0
        let y1 = 0.0

        for (const t in teeth) {
          if (t.x < x0) {
            x0 = t.x
          }

          if (t.y < y0) {
            y0 = t.y
          }

          const mx = t.x + t.w
          if (mx > x1) {
            x1 = mx
          }

          const my = t.y + t.h
          if (my > y1) {
            y1 = my
          }
        }


        const leaves = []

        return makeObject(Types.Empty, {
          update() {
            if (leaves.length >= 3 || rand() < 0.99) {
              return
            }

            const y = salad.y
            if (y > 0) {
              return
            }

            // find letter and hide it temporarily
            const index = flr(-y / salad.size)
            const text = salad.text[index]
            salad.hide(index)

            // spawn leaf
            const leaf = makeLeaf(text)
            leaves.push(leaf)

            // stick the leaf in a random tooth
            const smile = teeth.filter((t) => t.isClean())
            const tooth = smile[flr(rand() * smile.length)]
            tooth.stick(leaf)
          }
        })
      }

      function makeTooth(i) {
        const len = flr(kNumTeeth / 2)
        const row = flr(i / len)
        const col = i % len

        const s = makeSprite("tooth", {
          a: (row + 1) * Math.PI,
          z: row == 0 ? 2 : 0,
        })

        const w = s.w
        const h = s.h
        const ox = smp.sym(2.0)
        const oy = smp.sym(3.0)

        function animX() {
          return 80.0 + col * (w - 5.0) + ox
        }

        function animY() {
          const curve = crv.quad(mFrame % 30, 30)

          if (row == 0) {
            scale = 25.0 + curve * 5.0
          } else {
            scale = 10.0 + curve * 50.0
          }

          return 10.0 + row * h + crv.quad(col, len, scale) + oy
        }

        return {
          ...s,
          x: animX(),
          y: animY(),
          leaf: null,
          isClean() {
            return this.leaf == null
          },
          stick(leaf) {
            this.leaf = leaf
            this.updateLeaf(leaf)
            this.addChild(leaf)
          },
          update() {
            this.x = animX()
            this.y = animY()

            if (mFrame % 10 == 0) {
              this.tx = smp.sym(0.5)
              this.ty = smp.sym(0.5)
            }

            const leaf = this.leaf
            if (leaf != null) {
              this.updateLeaf(leaf)
            }
          },
          updateLeaf(leaf) {
            leaf.x = this.x + this.w / 4
            leaf.y = this.y
            leaf.z = this.z
          }
        }
      }

      function makeLeaf(text) {
        return makeText(text, {
          size: 80.0,
          a: smp.sym(Math.PI * 0.25),
        })
      }

      // w/primitives
      function makeText(text, props) {
        return makeObject(Types.Text, {
          text: text,
          x: 0.0,
          y: 0.0,
          a: 0.0,
          size: 0.0,
          down: false,
          ...props
        })
      }

      function makeSprite(name, props) {
        const asset = mAssets[name]

        return makeObject(Types.Sprite, {
          name: name,
          x: 0.0,
          y: 0.0,
          w: asset.width,
          h: asset.height,
          a: 0.0,
          tx: 0.0,
          ty: 0.0,
          hide: false,
          ...props
        })
      }

      function makeObject(type, props) {
        return {
          type: type,
          z: 0,
          ...props,
          addChild(child) {
            if (this.children == null) {
              this.children = []
            }

            this.children.push(child)
          }
        }
      }

      // -- draw --
      let mCanvas
      let mCtx

      function initDraw(el) {
        // configure canvas
        mCanvas = el
        mCanvas.setAttribute("width", kSize.x)
        mCanvas.setAttribute("height", kSize.y)

        // grab ref to drawing context
        mCtx = mCanvas.getContext("2d")
      }

      // -- d/commands
      function draw() {
        drawBackground();
        drawMany(mObjects)
      }

      function drawMany(objs) {
        let z = 0
        let zMax = 0

        do {
          for (const obj of objs) {
            if (obj.z > zMax) {
              zMax = obj.z
            }

            if (obj.z == z) {
              drawOne(obj)
            }
          }

          z += 1
        } while (z <= zMax)
      }

      function drawOne(obj) {
        switch (obj.type) {
          case Types.Text:
            drawText(obj); break
          case Types.Sprite:
            drawSprite(obj); break
        }

        if (obj.children != null) {
          drawMany(obj.children)
        }
      }

      function drawBackground() {
        mCtx.fillStyle = "papayawhip"
        mCtx.fillRect(0.0, 0.0, kSize.x, kSize.y);
      }

      function drawText(t) {
        const s = t.size

        mCtx.font = `${s}px serif`
        mCtx.fillStyle = "black"
        mCtx.textBaseline = "top"

        let x = t.x
        let y = t.y

        if (t.down) {
          let i = 0
          for (const char of t.text) {
            if (t.skip == null || !t.skip.includes(i)) {
              mCtx.fillText(char, x, y)
            }

            y += s
            i += 1
          }
        } else if (t.a != 0) {
          const r = mCtx.measureText(t.text)
          drawRotated(t.a, x, y, r.width, s, (x, y) => {
            mCtx.fillText(t.text, x, y)
          })
        } else {
          mCtx.fillText(t.text, x, y)
        }
      }

      function drawSprite(s) {
        const asset = mAssets[s.name]
        const x = s.x + s.tx
        const y = s.y + s.ty

        if (s.a == 0.0) {
          mCtx.drawImage(asset, x, y, s.w, s.h)
        } else {
          drawRotated(s.a, x, y, s.w, s.h, (x, y) => {
            mCtx.drawImage(asset, x, y, s.w, s.h);
          })
        }
      }

      function drawRotated(a, x, y, w, h, draw) {
        if (a < 0) {
          a = 2 * Math.PI + a
        }

        const w2 = w / 2
        const h2 = h / 2
        const cx = x + w2
        const cy = y + h2

        mCtx.translate(cx, cy);
        mCtx.rotate(a);
        draw(-w2, -h2)
        mCtx.rotate(-a);
        mCtx.translate(-cx, -cy);
      }

      // -- helpers --
      function nrm(value, len, scale = 1.0) {
        return min(value / (len - 1), 1.0) * scale
      }

      const smp = {
        sym(scale = 1.0) {
          return 2.0 * (rand() - 0.5) * scale
        }
      }

      const crv = {
        quad(val, len, scale = 1.0) {
          const l2 = len / 2
          const offset = len % 2 == 0 ? 0.5 : 0
          return (1 - pow((val - l2 + offset) / l2, 2.0)) * scale
        }
      }

      // -- "exports" --
      return Start
    })()
  </script>
</head>

<body onload='SaladDaze("game")'>
  <canvas id="game"></canvas>

  <!-- this probably won't work when loaded externally -->
  <object id="assets" style="display: none">
    <img id="tooth" src="./tooth.png">
  </object>
</body>
