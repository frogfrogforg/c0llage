<html style="--vh:13.43px;"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="twitter:card" value="summary">
    <meta name="twitter:title" value="mutthoughts" id="twitter-title">
    <meta name="twitter:image" value="https://kool.tools/domino/twitter-card.png">
    <meta name="twitter:image:alt" value="low fidelity image of many dominoes connected">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVQ4jWNkQANfHl77jy6GDHjktRiR+SgcQpqxGcKETcGRY+sZjhxbj5M/ElxACmBB5uByJj4w8F7AawC+0IeBQeYFYmIBXQ0LIQWEACO6wI7lrXjDwSOyGkUPAKUpOzwONiPPAAAAAElFTkSuQmCC">
    <title>mutthoughts</title>
    <script id="data" type="text/json">{"cards":[{"cell":[0,0],"text":"<h1> Mut </h1>","type":"heading","icons":[]},{"cell":[0,1],"text":"Will start testing this thing for the project, seems like a pretty cool tool","type":"basic-red","icons":[{"icon":"a","command":""},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[2,0],"text":"Had some extra ideas, but didn't want to overtake the thing, and I think other people might have interesting ideas as well\n","type":"basic-red","icons":[]},{"cell":[0,2],"text":"Hopefully it will help me out with motivation to write stuff fo the blog","type":"basic-red","icons":[]},{"cell":[2,-1],"text":"I really enjoyed making the sequential think where it slowly unlocked different games","type":"basic-red","icons":[]},{"cell":[-1,2],"text":"<h2> thoughts on this tool","type":"basic-red","icons":[]},{"cell":[2,-2],"text":"<h3> Thoughts on sequential","type":"basic-red","icons":[{"icon":"üßµ","command":"../gatherings/sequential-games.html"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[3,0],"text":"This also relates to an earlier idea of how some games are really meant to be played with a walkthrough","type":"basic-red","icons":[]},{"cell":[0,3],"text":"<h3> We had a retro and it was good","type":"basic-red","icons":[]},{"cell":[3,1],"text":"Makes me think of my experience with Sandcastle Builder and Dwarf Fortress","type":"basic-red","icons":[{"icon":"‚õèÔ∏è","command":"http://www.bay12games.com/dwarves/"},{"icon":"üè∞","command":"http://castle.chirpingmustard.com/"},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[3,-1],"text":"Might be funny to make a game thinking about how the walkthrough will be written down.","type":"basic-red","icons":[]},{"cell":[-1,-3],"text":"Made a cool game today\n","type":"basic-red","icons":[{"icon":"","command":""},{"icon":"","command":""},{"icon":"üîó","command":"https://lamen.itch.io/manivela"},{"icon":"","command":""}],"image":"data:image/jpeg;base64,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"},{"cell":[3,-2],"text":"Might be funny to make a game thinking about how the walkthrough will be written.","type":"basic-red","icons":[]},{"cell":[-2,3],"text":"It seems interesting, but the cards are pretty small, not great to write huge streams of conscience.","type":"basic-red","icons":[{"icon":"","command":""},{"icon":"üîó","command":"https://kool.tools/domino/#0,0"},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[2,-3],"text":"<h1> The idea zone! </h1>","type":"heading","icons":[]},{"cell":[0,4],"text":"The whole conversation on the retro was pretty fun, but I am curious what will and will not change because of it\n","type":"basic-red","icons":[]},{"cell":[0,-4],"text":"","type":"basic-red","icons":[],"image":"data:image/jpeg;base64,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"},{"cell":[-1,-4],"text":"<h1>Big Random Mess","type":"basic-red","icons":[]},{"cell":[4,1],"text":"Jason Grinblat is an interesting individual, just sent me into a derive on procedural narrative and bots and messy design","type":"basic-red","icons":[]},{"cell":[3,-3],"text":"While playing the latest mario version I realized how funny the \"walkthrough of the game currently sounds.","type":"basic-red","icons":[]},{"cell":[-2,4],"text":"Might have to eventually migrate to my other idea of using my great friend Dynalist","type":"basic-red","icons":[{"icon":"üöá","command":"https://dynalist.io/d/FBKaxfbkJ6EQypVo8cM0UNZw"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[4,2],"text":"This text about games that need wikis, that going through the wiki as a part of the fun, I like it","type":"basic-red","icons":[{"icon":"üìë","command":"https://mixedinitiatives.net/blog/apologia-for-game-wikis/"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[0,5],"text":"I also kind of wanted to write the rules we went by down and make small adjustments to it.","type":"basic-red","icons":[]},{"cell":[3,-4],"text":"The fun walkthrough \n|\nv","type":"basic-red","icons":[]},{"cell":[-3,4],"text":"Also, this thight grid is awkwards, my thoughts are more free form than this.","type":"basic-red","icons":[]},{"cell":[0,-5],"text":"","type":"basic-red","icons":[],"image":"data:image/jpeg;base64,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"},{"cell":[4,3],"text":"And also this Tania text about making messier games, very rich context, going against minimalist. Who was interested in minimalism??","type":"basic-red","icons":[{"icon":"üìë","command":"https://medium.com/kitfox-games/in-praise-of-messy-design-62722b88258e"},{"icon":"","command":""},{"icon":"","command":""},{"icon":"","command":""}]},{"cell":[3,4],"text":"Coming back to this column, reminds me of that game idea I had about a game that has a wiki, a bunch of stuff related but no real game","type":"basic-red","icons":[]},{"cell":[1,5],"text":"I also liked the part where we talked about making stuff more ritualistic. I think the retro was interesting because of this","type":"basic-red","icons":[]},{"cell":[-2,5],"text":"I wisht there was a good OSS version of Dynalist","type":"basic-red","icons":[]},{"cell":[-3,5],"text":"Kanaga keeps mentioning that infinite notes as the best game ever, is it like Miro?","type":"basic-red","icons":[]},{"cell":[3,5],"text":"Might talk about it tomorrow with the groups, it seems to fit having the unified end game as a imaginary thing created by the parts.","type":"basic-red","icons":[]},{"cell":[0,6],"text":"Curious if other groups would be interested in testing doing a retro as well","type":"basic-red","icons":[]},{"cell":[1,6],"text":"I think there's like two opposing forces in the group (even internal to myself). Probably another name for what Ty calls <a href=\"../the-problem.html\">the problem","type":"basic-red","icons":[]},{"cell":[3,6],"text":"And such parts can be presented in interesting ways, the end process can be awesome!","type":"basic-red","icons":[]},{"cell":[1,7],"text":"How does complete freedom/no process relates to structure/arbitrarily ritualized process works\n","type":"basic-red","icons":[]},{"cell":[-1,7],"text":"Speaking of other groups, I need to get access to other groups repos. Want to make SECRET PROJECT 2","type":"basic-red","icons":[]},{"cell":[-4,6],"text":"want to make the cards not stuck on a grid (or a finer grid, and make them resizeable.","type":"basic-red","icons":[]},{"cell":[2,6],"text":"<- red thru this 2day. thnkn of this note while reading nietzche desc. appolinian and dionysian art. r we repeating ancient artistic patterns? (sry 4 tchn yr blg)","type":"basic-blue","icons":[]}]}</script>
    <link href="https://fonts.googleapis.com/css?family=Lora&amp;display=swap" rel="stylesheet">
    <!-- third party libraries-->
    <script>var DragDropTouch;!function(t){"use strict";var e=function(){function t(){this._dropEffect="move",this._effectAllowed="all",this._data={}}return Object.defineProperty(t.prototype,"dropEffect",{get:function(){return this._dropEffect},set:function(t){this._dropEffect=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"effectAllowed",{get:function(){return this._effectAllowed},set:function(t){this._effectAllowed=t},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"types",{get:function(){return Object.keys(this._data)},enumerable:!0,configurable:!0}),t.prototype.clearData=function(t){null!=t?delete this._data[t]:this._data=null},t.prototype.getData=function(t){return this._data[t]||""},t.prototype.setData=function(t,e){this._data[t]=e},t.prototype.setDragImage=function(t,e,n){var s=i._instance;s._imgCustom=t,s._imgOffset={x:e,y:n}},t}();t.DataTransfer=e;var i=function(){function t(){if(this._lastClick=0,t._instance)throw"DragDropTouch instance already created.";var e=!1;if(document.addEventListener("test",function(){},{get passive(){return e=!0,!0}}),"ontouchstart"in document){var i=document,n=this._touchstart.bind(this),s=this._touchmove.bind(this),o=this._touchend.bind(this),r=!!e&&{passive:!1,capture:!1};i.addEventListener("touchstart",n,r),i.addEventListener("touchmove",s,r),i.addEventListener("touchend",o),i.addEventListener("touchcancel",o)}}return t.getInstance=function(){return t._instance},t.prototype._touchstart=function(e){var i=this;if(this._shouldHandle(e)){if(Date.now()-this._lastClick<t._DBLCLICK&&this._dispatchEvent(e,"dblclick",e.target))return e.preventDefault(),void this._reset();this._reset();var n=this._closestDraggable(e.target);n&&(this._dispatchEvent(e,"mousemove",e.target)||this._dispatchEvent(e,"mousedown",e.target)||(this._dragSource=n,this._ptDown=this._getPoint(e),this._lastTouch=e,e.preventDefault(),setTimeout(function(){i._dragSource==n&&null==i._img&&i._dispatchEvent(e,"contextmenu",n)&&i._reset()},t._CTXMENU),t._ISPRESSHOLDMODE&&(this._pressHoldInterval=setTimeout(function(){i._isDragEnabled=!0,i._touchmove(e)},t._PRESSHOLDAWAIT))))}},t.prototype._touchmove=function(t){if(this._shouldCancelPressHoldMove(t))this._reset();else if(this._shouldHandleMove(t)||this._shouldHandlePressHoldMove(t)){var e=this._getTarget(t);if(this._dispatchEvent(t,"mousemove",e))return this._lastTouch=t,void t.preventDefault();this._dragSource&&!this._img&&this._shouldStartDragging(t)&&(this._dispatchEvent(t,"dragstart",this._dragSource),this._createImage(t),this._dispatchEvent(t,"dragenter",e)),this._img&&(this._lastTouch=t,t.preventDefault(),e!=this._lastTarget&&(this._dispatchEvent(this._lastTouch,"dragleave",this._lastTarget),this._dispatchEvent(t,"dragenter",e),this._lastTarget=e),this._moveImage(t),this._isDropZone=this._dispatchEvent(t,"dragover",e))}},t.prototype._touchend=function(t){if(this._shouldHandle(t)){if(this._dispatchEvent(this._lastTouch,"mouseup",t.target))return void t.preventDefault();this._img||(this._dragSource=null,this._dispatchEvent(this._lastTouch,"click",t.target),this._lastClick=Date.now()),this._destroyImage(),this._dragSource&&(t.type.indexOf("cancel")<0&&this._isDropZone&&this._dispatchEvent(this._lastTouch,"drop",this._lastTarget),this._dispatchEvent(this._lastTouch,"dragend",this._dragSource),this._reset())}},t.prototype._shouldHandle=function(t){return t&&!t.defaultPrevented&&t.touches&&t.touches.length<2},t.prototype._shouldHandleMove=function(e){return!t._ISPRESSHOLDMODE&&this._shouldHandle(e)},t.prototype._shouldHandlePressHoldMove=function(e){return t._ISPRESSHOLDMODE&&this._isDragEnabled&&e&&e.touches&&e.touches.length},t.prototype._shouldCancelPressHoldMove=function(e){return t._ISPRESSHOLDMODE&&!this._isDragEnabled&&this._getDelta(e)>t._PRESSHOLDMARGIN},t.prototype._shouldStartDragging=function(e){var i=this._getDelta(e);return i>t._THRESHOLD||t._ISPRESSHOLDMODE&&i>=t._PRESSHOLDTHRESHOLD},t.prototype._reset=function(){this._destroyImage(),this._dragSource=null,this._lastTouch=null,this._lastTarget=null,this._ptDown=null,this._isDragEnabled=!1,this._isDropZone=!1,this._dataTransfer=new e,clearInterval(this._pressHoldInterval)},t.prototype._getPoint=function(t,e){return t&&t.touches&&(t=t.touches[0]),{x:e?t.pageX:t.clientX,y:e?t.pageY:t.clientY}},t.prototype._getDelta=function(e){if(t._ISPRESSHOLDMODE&&!this._ptDown)return 0;var i=this._getPoint(e);return Math.abs(i.x-this._ptDown.x)+Math.abs(i.y-this._ptDown.y)},t.prototype._getTarget=function(t){for(var e=this._getPoint(t),i=document.elementFromPoint(e.x,e.y);i&&"none"==getComputedStyle(i).pointerEvents;)i=i.parentElement;return i},t.prototype._createImage=function(e){this._img&&this._destroyImage();var i=this._imgCustom||this._dragSource;if(this._img=i.cloneNode(!0),this._copyStyle(i,this._img),this._img.style.top=this._img.style.left="-9999px",this._img.style.transform="none",!this._imgCustom){var n=i.getBoundingClientRect(),s=this._getPoint(e);this._imgOffset={x:s.x-n.left,y:s.y-n.top},this._img.style.opacity=t._OPACITY.toString()}this._moveImage(e),document.body.appendChild(this._img)},t.prototype._destroyImage=function(){this._img&&this._img.parentElement&&this._img.parentElement.removeChild(this._img),this._img=null,this._imgCustom=null},t.prototype._moveImage=function(t){var e=this;requestAnimationFrame(function(){if(e._img){var i=e._getPoint(t,!0),n=e._img.style;n.position="absolute",n.pointerEvents="none",n.zIndex="999999",n.left=Math.round(i.x-e._imgOffset.x)+"px",n.top=Math.round(i.y-e._imgOffset.y)+"px"}})},t.prototype._copyProps=function(t,e,i){for(var n=0;n<i.length;n++){var s=i[n];t[s]=e[s]}},t.prototype._copyStyle=function(e,i){if(t._rmvAtts.forEach(function(t){i.removeAttribute(t)}),e instanceof HTMLCanvasElement){var n=e,s=i;s.width=n.width,s.height=n.height,s.getContext("2d").drawImage(n,0,0)}for(var o=getComputedStyle(e),r=0;r<o.length;r++){var a=o[r];a.indexOf("transition")<0&&(i.style[a]=o[a])}i.style.pointerEvents="none";for(r=0;r<e.children.length;r++)this._copyStyle(e.children[r],i.children[r])},t.prototype._dispatchEvent=function(e,i,n){if(e&&n){var s=document.createEvent("Event"),o=e.touches?e.touches[0]:e;return s.initEvent(i,!0,!0),s.button=0,s.which=s.buttons=1,this._copyProps(s,e,t._kbdProps),this._copyProps(s,o,t._ptProps),s.dataTransfer=this._dataTransfer,n.dispatchEvent(s),s.defaultPrevented}return!1},t.prototype._closestDraggable=function(t){for(;t;t=t.parentElement)if(t.hasAttribute("draggable")&&t.draggable)return t;return null},t}();i._instance=new i,i._THRESHOLD=5,i._OPACITY=.5,i._DBLCLICK=500,i._CTXMENU=900,i._ISPRESSHOLDMODE=!1,i._PRESSHOLDAWAIT=400,i._PRESSHOLDMARGIN=25,i._PRESSHOLDTHRESHOLD=0,i._rmvAtts="id,class,style,draggable".split(","),i._kbdProps="altKey,ctrlKey,metaKey,shiftKey".split(","),i._ptProps="pageX,pageY,clientX,clientY,screenX,screenY".split(","),t.DragDropTouch=i}(DragDropTouch||(DragDropTouch={}));

    </script>
    <script>/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}
    </script>
    <!-- styles-->
    <style id="base-style">:root {
    --font-family: lora;
    --font-size: 1.1em;
    --editor-background: rgb(240, 248, 255);
    --panel-width: 420px;

    touch-action: none;

    color: var(--background-text-color, black);
    background: var(--background-color, white);
    font-family: var(--font-family, serif);
    font-size: var(--font-size, 1.1em);
}

/* prevent weird highlights https://stackoverflow.com/questions/21003535/ */
.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* hidden elements should be hidden regardless of their display style */
[hidden] { display: none !important; }

/* default to width/height including padding and border */
* { box-sizing: border-box; }

/* used dynamically to prevent or cancel smooth transitions */
.skip-transition { transition: none !important; }

/* make buttons inherit font */ 
button { font-family: inherit; font-size: inherit; }

/* clickable things should use this cursor imo */
button, a, [data-click-to-hide], [data-tab], [data-close-parent-screen] { cursor: pointer; }

/* draggable things get their own cursor */
[draggable="true"] { cursor: copy !important; }

/* before grab-panning, screen has a grab cursor */
#pan-screen { cursor: grab; }
/* while grab-panning, blocker has a grabbing cursor */
#pan-blocker { cursor: grabbing; }

/* match viewport size, hide anything outside of bounds */
.full-viewport, html, body, .screen, #pan-screen, #pan-blocker {
    position: absolute;
    margin: 0;
    padding: 0;
    overflow: hidden;

    width: 100vw;
    /* there are caveats to viewport height on mobile
       https://stackoverflow.com/questions/37112218/css3-100vh-not-constant-in-mobile-browser */
    height: calc(var(--vh, 1vh) * 100);
}

/* default to no margin for card content */
.card * { margin: 0; }

td { padding: .5em; }
p { margin-block-start: .75em; margin-block-end: .75em; }
h2 { margin-block-end: .5em; }
h2:first-child { margin-block-start: 0; }

.button-list {
    display: flex;
    flex-flow: row wrap;
    align-items: flex-start;
    align-content: flex-start;
}

.button-list > * {
    margin: .25em;
    flex: 1 1 auto;
}

/* point centered on the middle of the screen. this is the parent of all the 
   cards and the element that changes when navigating */
#scene {
    position: absolute; left: 50%; top: 50%;
    width: 0; height: 0;

    /* i think this helps streamline the panning by telling the browser that it
       will be constantly moving
       https://stackoverflow.com/questions/26907265/css-will-change-how-to-use-it-how-it-works */
    will-change: transform;
    transition: transform .2s ease-in-out;
}

/* generic tabbed pages styles */
.tab-bar {
    display: grid;
    grid-auto-flow: column;
    color: white;
    background:black;
}

.tab-bar > * {
    padding: 1em;
    text-align: center;
}

.tab-bar > *.selected {
    color: black;
    background: var(--editor-background);
}

.tab-page {
    margin: 0;
    padding: 2em;
    overflow: auto;

    flex: 1;
    display: flex;
    flex-direction: column;
}
/* end of tabbed pages styles */

/* standard style for text inputs */
textarea, input[type="text"] {
    resize: none;
    border: 1px solid black;
    padding: .5em;
    flex: 1;

    font-family: monospace;
    font-size: inherit;
}

#board-title {
    font-family: inherit;
    font-size: inherit;
}

#style-input {
    min-height: 20em;
}

.editor-page {
    padding: 1em;
    height: 100%;
    display: flex;

    flex-direction: column;
}

/* editor icons page styles */
.editor-page[data-page="icons"] {
    display: grid;

    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);

    column-gap: 1em;
    row-gap: 1em;
}

.icon-select {
    min-width: 3em;
    text-align: center;
    font-size: 1em;

    grid-column-start: 1;
    grid-column-end: 2;
}

.icon-command {
    font-size: 1em;
    font-family: monospace;

    grid-column-start: 2;
    grid-column-end: 5;
}
/* end of editor icons page styles */

.card h3 {
    display: block; 
    font-size: 1.5em; 
    font-weight: bold;
    text-align: center;

    margin-bottom: .5em;
}

/* tile coordinates display */
#coords {
    position: absolute; left: 0; top: 0;

    font-family: monospace;
    margin: .25em;
    padding: .25em .5em;
    border-radius: .75em;

    background: var(--background-color);
}

/* image display popout */
#display-image {
    position: absolute; left: 50%; top: 50%;
    transform: translate(-50%, -50%);
}

/* iframe display popout */
#display-frame {
    position: absolute; left: 50%; top: 50%;
    transform: translate(-50%, -50%);

    background: white;
    margin: 0;
    padding: 0;

    width: 800px;
    height: 600px;
    max-width: 100%;
    max-height: 100%;
}

.screen {
    background-color: rgb(0, 0, 0, .25);
}

.full-panel {
    cursor: auto;
    padding: 0;

    width: var(--panel-width);
    height: 100%;
    max-width: 100%;

    color: black;
    background-color: var(--editor-background);
    overflow: hidden;
    
    display: flex;
    flex-direction: column;
}

#content-input {
    padding: 1em;
}

#type-select {
    margin-bottom: 1em;
    flex: 1;
}

#type-select > *.selected {
    filter: invert();
}

.card {
    position: absolute;

    transition: transform .2s ease-in-out, opacity .2s ease-in-out;

    width: var(--card-width, 15em);
    height: var(--card-height, 9em);

    display: flex;
    margin: 0;
    word-wrap: break-word;

    background-size: cover;
}

.card-text {
    width: 100%;
    padding: 1em;
}

.icon-bar {
    position: absolute;
    
    display: grid;
    gap: .5em;
    margin: 0;
}

.icon-bar > * {
    width: 2em;
    height: 2em;
    grid-row: 1;

    padding: 0;
    
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
}

.card-icon-bar {
    left: 50%; bottom: 0;
    transform: translate(-50%, 50%);

    font-size: 1rem;
    column-gap: .75em;
}

.card-edit-bar {
    right: 0; top: 50%;
    transform: translate(50%, -50%);

    font-size: 1.25em;
}

.card-edit-bar > * {
    grid-row: auto;
    grid-column: 1;

    background: rgb(240, 240, 240);
    border: 1px solid black;
    border-radius: 100%;
    cursor: pointer;
}

#link-card {
    cursor: copy;
}

.card-icon-bar > * {
    width: 2em;
    height: 2em;

    transition: transform .1s ease-in-out;
}

.card-icon-bar > *:hover  { transform: scale(1.5); }
.card-icon-bar > *:active { transform: scale(2);   }
/* don't animate cosmetic card icons */
.card-icon-bar > *.cosmetic { cursor: initial; transform: unset; }
/* don't respond to blank card icons */
.card-icon-bar > *.blank { pointer-events: none; transform: unset; }

/* main toolbar */
#toolbar {
    left: 50%; bottom: 0;
    transform: translate(-50%, 0);
    
    font-size: 1.5em;
    padding: .5em;
}

/* main toolbar buttons */
#toolbar > * {
    background: rgb(240, 240, 240);
    border: 1px solid black;
    border-radius: 100%;
    cursor: pointer;
}

#editor-preview {
    width: 100%;
    height: calc(var(--card-height) * 2);
    min-height: calc(100% - var(--card-height) * 2);
}

#editor-section {
    position: absolute; left: 50%; bottom: 0;
    transform: translateX(-50%);

    background: var(--editor-background);
    pointer-events: initial;
    cursor: initial;

    width: 400px;
    max-width: 100%;
    height: calc(100% - var(--card-height) * 2);
    max-height: calc(var(--card-height) * 2);

    display: flex;
    flex-direction: column;
}

    </style>
    <style id="user-style">:root {
    --background-color: rgb(255, 245, 209);
    --background-text-color: black;

    --card-width: 15rem;
    --card-height: 9rem;
    --card-gap-horizontal: 2em;
    --card-gap-vertical: 2em;
}

/* base style for cards */
.card {
    background-color: white;
    color: black;

    /* tiny curve on corners */
    border-radius: .5em;
    /* thick black line below */
    border-bottom: 3px solid black;
}

.card.has-image {
    background-repeat: no-repeat;
    background-position: center;
    /* white text with black outline */
    color: white;
    text-shadow: 
         1px  1px 1px black,
        -1px  1px 1px black,
        -1px -1px 1px black,
         1px -1px 1px black;
}

/* cut off any text that goes outside the bounds of the card */
.card-text {
    overflow: hidden;
}

/* custom card styles */
.domino-card-basic-red   { 
    background-color: #FDE9C6; 
}

.domino-card-basic-green { 
    background-color: #F0EDC5; 
}

.domino-card-basic-blue  { 
    background-color: #F2EED2; 
}

.domino-card-heading { 
    background-color: #F3E9C7;
    align-items: center;
}

/* border from http://todrobbins.com/broider-gallery/ */
.domino-card-broider-example {
    background-color: transparent;
    border-style: solid;
    border-width: .5em;
    align-items: center;
    text-align: center;
    font-family: monospace;
    box-sizing: content-box;
    border-image:  url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAABaElEQVR4nO2WQQ7DMAzD+v9Pbz9oQVhRs4wEclMci4ei13Vdn/JpU++nUIUiFBpmO6HpAmkBq/fB8xTKUOjwPp6nUAYWSgdO81QgFVTvp9BwXqHhvELD+XRhuuB03ur38XyFKlShCr0hnaeF0kLjeYWG8woN5xUaztMF6QPTBVfPozzOUyhDocP7eJ5CGWOh6dOm3k+hCkUoNMzp/URE/orTP8r1fgpVKEKhYZb3O/1Ht95PoQpFKDTMdkKn+bep91PoLP/+g2UUGmY7ofTsRr2fQhWKUGiY1/v9usAn6v0UqlCEQsOc3k9E5KdI/+ju9lGv91OoQhEKDbOd0HSBtIDV++B5CmUodHgfz1MoAwulA6d5KpAKqvdTaDiv0HBeoeF8ujBdcDpv9ft4vkIVqlCF3pDO00JpofG8QsN5hYbzCg3n6YL0gemCq+dRHucplKHQ4X08T6GMsdD0aVPvp1CFIhQaptrvC1EVM4TVl2v7AAAAAElFTkSuQmCC") 28 /  1em / 0 round;
}

/* custom bold style */
.domino-card-broider-example strong {
    color: white;
    text-shadow: 1px 1px 1px black;
    font-size: 1.5em;
}

/* adding halo around icons */
.domino-card-broider-example > .card-icon-bar > *:not(.blank) {
    text-shadow: 
        0 0 5px var(--background-color),
        0 0 5px var(--background-color),
        0 0 5px var(--background-color),
        0 0 5px var(--background-color);
}

    </style>
    <!-- scripts-->
    <script>'use strict'

const ONE = (query, element) => (element || document).querySelector(query);
const ALL = (query, element) => Array.from((element || document).querySelectorAll(query));

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const makeCounter = (count=0) => () => count++;
const remToPx = em => emToPx(document.documentElement, em);
const emToPx = (element, em) => Math.round(em * parseFloat(getComputedStyle(element).fontSize));
const setElementJsonData = (element, data) => queryToElement(element).innerHTML = JSON.stringify(data);
const getElementJsonData = (element) => JSON.parse(queryToElement(element).innerHTML);
const reflow = element => void(element.offsetHeight);
const coordsToKey = (coords) => coords.join(',');

const add = (a, b) => [a[0] + b[0], a[1] + b[1]];
const sub = (a, b) => [a[0] - b[0], a[1] - b[1]];
const sqr = a => a[0] * a[0] + a[1] * a[1];
const sqrdist = (a, b) => sqr(sub(a, b));

function say(text) {
    const utter = new SpeechSynthesisUtterance(text);
    window.speechSynthesis.speak(utter);
}

function toggleFullscreen() {
    if (document.fullscreenElement) {
        return document.exitFullscreen();
    } else {
        return document.documentElement.requestFullscreen({ navigationUI: 'hide' });
    }
}

async function textFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(reader.result);
        reader.readAsText(file); 
    });
}

async function dataURLFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(file); 
    });
}

function filesFromDataTransfer(dataTransfer) {
    const clipboardFiles = 
        Array.from(dataTransfer.items || [])
        .filter(item => item.kind === 'file')
        .map(item => item.getAsFile());
    return clipboardFiles.concat(...(dataTransfer.files || []));
}

function elementFromDataTransfer(dataTransfer) {
    const html = dataTransfer.getData('text/html');
    return html && stringToElement(html);
}

async function compressImageURL(url, quality, size) {
    const image = document.createElement("img");
    image.crossOrigin = true;
    const canvas = document.createElement("canvas");

    const [tw, th] = size;
    canvas.width = tw;
    canvas.height = th;

    return new Promise((resolve, reject) => {
        image.onload = () => {
            const scale = Math.max(tw / image.width, th / image.height);
            const [fw, fh] = [image.width * scale, image.height * scale];
            const [ox, oy] = [(tw - fw)/2, (th - fh)/2];

            const context = canvas.getContext('2d');
            context.drawImage(image, ox, oy, fw, fh);
            const url = canvas.toDataURL('image/jpeg', quality);

            console.log(`${url.length}B`);
            resolve(url);
        };
        image.onerror = () => resolve(undefined);
        image.src = url;
    });
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function killEvent(event) {
    event.stopPropagation();
    event.preventDefault();
}

function eventToElementPixel(event, element) {
    const rect = element.getBoundingClientRect();
    return [event.clientX - rect.x, event.clientY - rect.y];
}

function getElementCenter(element) {
    return [element.clientWidth / 2, element.clientHeight / 2];
}

function getElementCenterClient(element) {
    const rect = element.getBoundingClientRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
}

function queryToElement(query) {
    return (query instanceof Element) ? query : ONE(query);
}

function cloneTemplateElement(query) {
    const template = queryToElement(query);
    const clone = template.cloneNode(true);
    clone.removeAttribute('id');
    return clone;
}

function addListener(query, type, listener) {
    queryToElement(query).addEventListener(type, listener);
}

function chunkedForeach(array, interval, callback) {
    return new Promise((resolve, reject) => {
        let deadline = performance.now() + interval;
        let index = 0;

        const doChunk = () => {
            for (; index < array.length && performance.now() < deadline; ++index)
                callback(array[index]);
            deadline = performance.now() + interval;
            if (index < array.length)
                window.requestAnimationFrame(doChunk);
            else
                resolve()
        };

        window.requestAnimationFrame(doChunk);
    });
}

class CoordStore {
    constructor() { this.store = new Map(); }
    get size() { return this.store.size; }
    get(coords) { return this.store.get(coordsToKey(coords)); }
    set(coords, value) { return this.store.set(coordsToKey(coords), value); }
    delete(coords) { return this.store.delete(coordsToKey(coords)); }
    has(coords) { return this.store.has(coordsToKey(coords)); }
}

// based on https://www.redblobgames.com/grids/hexagons/
class HexGrid {
    constructor(cellSize) {
        this.cellSize = cellSize;
    }

    cellToPixel(cellCoords) {
        const [q, r] = cellCoords;
        const [w, h] = this.cellSize;

        const x = q * w;
        const y = (r + q / 2) * h;
        return [x, y];
    }

    pixelToCell(pixelCoords) {
        const [x, y] = pixelCoords;
        const [w, h] = this.cellSize;
        // pixel to axial coordinates
        const q = x / w;
        const r = y / h - q / 2;
        // convert axial to cube coordinates
        const [cx, cy, cz] = [q, r, -q-r];
        // determine rounding error
        let [rx, ry, rz] = [cx, cy, cz].map(Math.round);
        const [dx, dy, dz] = [rx - cx, ry - cy, rz - cz].map(Math.abs);
        // recompute worst coordinate from others
        if (dx > dy && dx > dz) {
            rx = -ry-rz
        } else if (dy > dz) {
            ry = -rx-rz
        } else {
            rz = -rx-ry
        }
        // return axial components
        return [rx, ry];
    }
}

function listen(element, type, listener) {
    element.addEventListener(type, listener);
    return () => element.removeEventListener(type, listener);
}

    </script>
    <script>'use strict';

const cardStyleRegex = /\.domino-card-([a-zA-Z0-9-_]+)/;
function findCardStyleNames() {
    const styles = new Set();
    Array.from(document.styleSheets).forEach(sheet => {
        try {
            for (const rule of sheet.cssRules) {
                const names = rule.selectorText.match(cardStyleRegex);
                if (names)
                    styles.add(names[1]);
            }
        } catch (e) {}
    });
    return Array.from(styles);
}

function fakedownToTag(text, fd, tag) {
    const pattern = new RegExp(`${fd}([^${fd}]+)${fd}`, 'g');
    return text.replace(pattern, `<${tag}>$1</${tag}>`);
}

function parseFakedown(text) {
    if (text.startsWith('`'))
        return `<pre>${text.slice(1)}</pre>`;
    text = text.replace(/([^-])--([^-])/g, '$1‚Äî$2');
    text = fakedownToTag(text, '##', 'h3');
    text = fakedownToTag(text, '~~', 's');
    text = fakedownToTag(text, '__', 'strong');
    text = fakedownToTag(text, '\\*\\*', 'strong');
    text = fakedownToTag(text, '_', 'em');
    text = fakedownToTag(text, '\\*', 'em');
    text = text.replace(/\n/g, '<br>');
    return text;
}

let pageSetters = new Map();
const clicks = ['pointerdown', 'pointerup', 'click', 'wheel', 'dblclick'];
function setupClassHooks() {
    ALL('[data-block-clicks]').forEach(element => {
        for (let name of clicks)
            element.addEventListener(name, event => event.stopPropagation());
    });
    ALL('[data-click-to-hide]').forEach(element => {
        element.addEventListener('pointerdown', () => element.hidden = true);
        for (let name of clicks)
            element.addEventListener(name, event => event.stopPropagation());
    });
    ALL('[data-close-parent-screen]').forEach(element => {
        const screen = element.closest('.screen');
        element.addEventListener('click', () => screen.hidden = true);
        element.addEventListener('pointerdown', () => screen.hidden = true);
    });

    ALL('button').forEach(element => {
        if (!element.draggable)
            for (let name of clicks)
                element.addEventListener(name, event => event.stopPropagation());
    })

    const tabsets = new Set(
        ALL('[data-tab-set]')
        .map(element => element.getAttribute('data-tab-set'))
    );

    tabsets.forEach(tabset => {
        const pages = new Map();
        const tabs = new Map();

        const setPage = pageName => {
            for (let tab of tabs.values())
                tab.classList.remove('selected');
            for (let page of pages.values())
                page.hidden = true;

            tabs.get(pageName).classList.add('selected');
            pages.get(pageName).hidden = false;
        };

        pageSetters.set(tabset, setPage);

        ALL(`[data-tab][data-tab-set="${tabset}"]`).forEach(element => {
            const pageName = element.getAttribute('data-tab');
            tabs.set(pageName, element);
            element.addEventListener('click', () => setPage(pageName));
        });

        ALL(`[data-page][data-tab-set="${tabset}"]`).forEach(element => {
            const pageName = element.getAttribute('data-page');
            pages.set(pageName, element);
        });
    });
}

function updateDocumentVariables() {
    const vh = window.innerHeight / 100;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

function computeCardSize(parent) {
    const testCard = cloneTemplateElement('#card-template');
    parent.appendChild(testCard);
    const size = [testCard.clientWidth, testCard.clientHeight];
    parent.removeChild(testCard);
    return size;
}

function computeCardGap() {
    const measure = document.createElement('div');
    measure.style = 'width: var(--card-gap-horizontal, 0); height: var(--card-gap-vertical, 0);';
    document.documentElement.appendChild(measure);
    const rect = measure.getBoundingClientRect();
    document.documentElement.removeChild(measure);
    return [rect.width, rect.height];
}

function stringToDocument(string) {
    const template = document.createElement('template');
    template.innerHTML = string;
    return template.content;
}

function stringToElement(string) {
    return stringToDocument(string).children[0];
}

async function htmlFromUrl(url) {
    const source = await (await fetch(url)).text();
    return stringToDocument(source);
}

async function htmlFromFile(file) {
    const source = await textFromFile(file);
    const html = stringToDocument(source);
    return html;
}

async function extractDataFromHtmlFile(file) {
    const source = await textFromFile(file);
    const html = stringToElement(source);
    return getElementJsonData(ONE('#data', html));
}

async function fileToCompressedImage(file) {
    const url = await dataURLFromFile(file);
    const dataURL = await compressImageURL(url, 0.2, domino.cardSize);
    return dataURL;
}

async function dataTransferToImage(dt) {
    const files = filesFromDataTransfer(dt);
    const element = elementFromDataTransfer(dt);
    const originURL = element && element.src; 
    if (files.length > 0) {
        const dataURL = await fileToCompressedImage(files[0]);
        return { dataURL, originURL };
    } else if (element && element.nodeName === 'IMG') {
        const dataURL = await compressImageURL(element.src, .2, domino.cardSize);
        return { dataURL, originURL };
    }
}

function projectToHTML() {
    setElementJsonData('#data', domino.getData());
    const clone = document.documentElement.cloneNode(true);
    ALL('[data-export-clear]', clone).forEach(element => element.innerHTML = '');
    ALL('[data-export-hide]', clone).forEach(element => element.hidden = true);
    const html = clone.outerHTML;
    const title = ONE('title').innerHTML;
    const name = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    return { html, name };
}

function exportProject() {
    const { html, name } = projectToHTML();
    const blob = new Blob([html], {type: "text/html"});
    saveAs(blob, `${name}.html`);
}

function getCoordsFromHash() {
    try {
        const coords = location.hash.slice(1).split(',').map(i => parseInt(i) || 0);
        if (coords.length === 2) return coords;
    } catch(e) {}

    return [0, 0];
}

class Domino {
    constructor() {
        this.cellToView = new CoordStore();
        this.focusedCell = [0, 0];
        this._focus = [0, 0];
        this._scaling = 1;
        this.selectedCardView = undefined;
    }

    play(url) {
        if (this.audio) this.audio.pause();
        this.audio = new Audio(url)
        this.audio.play();
    }

    display(url, size=[800, 600]) {
        const frame = ONE('#display-frame');
        const [w, h] = size;
        ONE('#display-screen').hidden = false;
        frame.onerror = () => window.open(url);
        frame.src = url;
        frame.style.width = w;
        frame.style.height = h;
    }

    async runCommand(command) {
        if (command.startsWith('#')) {
            location.href = command;
            domino.focusCell(getCoordsFromHash());
        } else if (command.startsWith('jump:')) {
            location.href = '#' + command.slice(5);
            domino.focusCell(getCoordsFromHash());
        } else if (command.startsWith('open:')) {
            window.open(command.slice(5));
        } else if (command.startsWith('display:')) {
            const src = command.slice(8);
            this.display(src);
        } else if (command.startsWith('play:')) {
            this.play(command.slice(5));
        } else if (command.startsWith('import:')) {
            const src = command.slice(7);
            const html = await htmlFromUrl(src);
            this.setFromHtml(html);
        } else if (command.length > 0) {
            window.open(command);
        }
    }

    set focus(focus) {
        this._focus = focus;
        this.refreshTransform();
        this.refreshHash();
    }

    get focus() {
        return this._focus;
    }

    set scale(scaling) {
        this._scaling = scaling;
        this.refreshTransform();
    }

    get scale() {
        return this._scaling;
    }

    haltPanningTransition() {
        if (this.scene.classList.contains('skip-transition')) 
            return;

        this.scene.style.transform = window.getComputedStyle(this.scene).transform;
        this.scene.classList.add('skip-transition');
        reflow(this.scene);
        this.scene.classList.remove('skip-transition');
        reflow(this.scene);
    }

    refreshTransform() {
        let [x, y] = this._focus;
        x = Math.round(x);
        y = Math.round(y);
        const s = this._scaling;
        this.scene.style.transform = `scale(${s}) translate(${-x}px, ${-y}px)`;
    }

    refreshHash() {
        const [q, r] = this.grid.pixelToCell(this.focus);
        this.focusedCell = [q, r];
        this.coords.innerHTML = `#${q},${r}`;

        if (this.pan) return;
        history.pushState({}, "", `#${q},${r}`)
    }

    focusCell(cell) {
        if (this.pan) return;
        this.haltPanningTransition();
        this.focus = this.grid.cellToPixel(cell);
        this.selectCardView(this.cellToView.get(cell));
    }

    focusCellNoTransition(coords) {
        this.scene.classList.add('skip-transition');
        this.focusCell(coords);
        reflow(this.scene);
        this.scene.classList.remove('skip-transition');
    }

    getOrSpawnCard(cell) {
        const blankCard = { cell, text: '', type: domino.editorScreen.types[0], icons: [] };
        return domino.cellToView.get(cell) || domino.spawnCard(blankCard);
    }

    spawnCard(card) {
        const view = this.addCard(card);
        view.transition = false;
        reflow(view.root);
        view.transition = true;
        view.triggerSpawnAnimation();
        return view;
    }

    addCard(card) {
        const view = new CardView(card);

        view.root.addEventListener('pointerdown', e => this.onCardPointerDown(view, e));
        view.root.addEventListener('click', e => this.selectCardView(view));
        view.root.addEventListener('dblclick', e => this.onCardClick(view, e));
        view.root.addEventListener('dragstart', e => this.onCardDragStart(view, e));

        this.scene.appendChild(view.root);
        this.moveCardToCell(view, card.cell);
    
        return view;
    }

    removeCard(view) {
        this.scene.removeChild(view.root);
        this.cellToView.delete(view.cell);

        if (this.editorScreen.activeView === view)
            this.editorScreen.setActiveView(undefined);
    }

    moveCardToCell(view, cell) {
        view.card.cell = cell;
        view.position = this.grid.cellToPixel(cell);
        this.cellToView.set(cell, view);
    }

    swapCells(a, b) {
        const aView = this.cellToView.get(a);
        const bView = this.cellToView.get(b);
    
        this.cellToView.delete(a);
        this.cellToView.delete(b);
    
        if (aView)
            this.moveCardToCell(aView, b);
        if (bView)
            this.moveCardToCell(bView, a);
    }

    refreshStyle() {
        this.editorScreen.refreshAvailableStyles();
        const [cw, ch] = computeCardSize(this.scene);
        const [sw, sh] = computeCardGap();
        this.cardSize = [cw, ch];
        this.grid = new HexGrid([cw + sw, ch + sh]);

        this.cellToView.store.forEach(view => {
            this.moveCardToCell(view, view.card.cell);
        });

        this.styleInput.value = ONE('#user-style').innerHTML;
    }

    pointerEventToGridPixel(event) {
        const [x, y] = eventToElementPixel(event, this.scene);
        const pixel = [x / this.scale, y / this.scale];
        return pixel;
    }

    pointerEventToCell(event) {
        const pixel = this.pointerEventToGridPixel(event);
        return this.grid.pixelToCell(pixel);
    }

    clear() {
        this.deselect();
        this.scene.innerHTML = "";
        this.cellToView.store.clear();
    }

    setFromHtml(html) {
        const style = ONE('#user-style', html).innerHTML;
        const data = JSON.parse(ONE('#data', html).innerHTML);
        ONE('title').innerHTML = ONE('title', html).innerHTML;
        ONE('#user-style').innerHTML = style;
        this.refreshStyle();
        this.setData(data);
    }

    setData(data) {
        ONE('#load-screen').hidden = false;
        this.clear();
        data.cards.sort((a, b) => sqrdist(a.cell, this.focusedCell) - sqrdist(b.cell, this.focusedCell));
        const loadCard = card => this.addCard(card).transition = false;
        chunkedForeach(data.cards, 30, loadCard)
        .then(() => sleep(1))
        .then(() => {
            for (let view of this.cellToView.store.values())
                view.transition = true;
            ONE('#load-screen').hidden = true;
        });
    }

    getData() {
        const views = Array.from(this.cellToView.store.values());
        const cards = views.map(view => view.card);
        return { cards };
    }

    setup() {
        this.editorScreen = new CardEditor();
        this.editorPreview = ONE('#editor-preview');
        this.scene = ONE('#scene');
        this.coords = ONE('#coords');
        
        this.styleInput = ONE('#style-input');
        this.refreshStyle();

        // hide fullscreen button if fullscreen is not possible
        if (!document.fullscreenEnabled)
            ONE('#fullscreen').hidden = true;

        this.cardbar = cloneTemplateElement('#cardbar-template');
        this.cardbar.id = 'cardbar';
        this.cardbar.hidden = false;
        this.addDeleteCardIcon = ONE('#add-delete-icon');
        this.aboutScreen = ONE('#menu-screen');
        this.lockedButton = ONE('#locked');
        this.unlockedButton = ONE('#unlocked');

        addListener(this.lockedButton,   'click', () => this.setUnlocked(true));
        addListener(this.unlockedButton, 'click', () => this.setUnlocked(false));

        const cardEditButton = ONE('#edit-card', this.cardbar);
        const cardLinkButton = ONE('#link-card', this.cardbar);
        const importFile = ONE('#import-file');
        const screen = ONE('#pan-screen');

        const onClickedCell = (event) => {
            if (this.pan) return;
            if (event.button && event.button === 2) 
                return;
            killEvent(event);
            this.deselect();
            this.focusCell(this.pointerEventToCell(event));
            if (this.unlocked)
                this.editFocusedCell();
            this.scale = 1;
        }

        const title = ONE('title');
        const boardTitle = ONE('#board-title');
        const twitterTitle = ONE('#twitter-title');
        boardTitle.addEventListener('input', () => {
            title.innerHTML = boardTitle.value;
            twitterTitle.setAttribute('value', boardTitle.value);
        });
        boardTitle.value = title.innerHTML;

        this.styleInput.addEventListener('input', () => {
            ONE('#user-style').innerHTML = this.styleInput.value;
            this.refreshStyle();
        });

        // clicking listeners
        addListener(cardEditButton, 'click', e => { killEvent(e); this.editCardView(this.selectedCardView); });
        addListener('#center',      'click', e => { killEvent(e);  this.focusCell([0, 0]); });
        addListener('#open-about',  'click', e => { killEvent(e);  this.aboutScreen.hidden = false; });
        addListener('#reset',       'click', e => this.clear());
        addListener('#import',      'click', e => importFile.click());
        addListener('#export',      'click', e => exportProject());
        addListener('#fullscreen',  'click', e => toggleFullscreen());

        const panBlocker = ONE('#pan-blocker');

        this.pan = undefined;
        this.touches = new Map();
        
        addListener('#zoom', 'click', event => {
            this.toggleZoom();
            killEvent(event);
        });

        const onDown = event => {
            this.pan = {
                scenePosition: this.pointerEventToGridPixel(event),
                pointerId: event.pointerId,
            };
            this.scene.classList.add('skip-transition');
            panBlocker.hidden = false;
            event.stopPropagation();
        };

        panBlocker.addEventListener('pointerdown', onDown);
        window.addEventListener('pointerdown', onDown);
        
        window.addEventListener('dblclick', () => onClickedCell(event));

        const onDonePanning = event => {
            panBlocker.hidden = true;
            this.pan = undefined;
            this.scene.classList.remove('skip-transition');
            event.stopPropagation();
            this.refreshHash();
        };

        panBlocker.addEventListener('pointerup', onDonePanning);
        window.addEventListener('pointerup', onDonePanning);
        
        const onMove = event => {
            if (!this.pan) return;

            // where we clicked in the scene
            const [sx, sy] = this.pan.scenePosition;
            // where we are in the scene now
            const [ax, ay] = this.pointerEventToGridPixel(event);
            // the error
            const [dx, dy] = [sx - ax, sy - ay];
            const [fx, fy] = this.focus;
            this.focus = [fx + dx, fy + dy];

            killEvent(event);
        };

        panBlocker.addEventListener('pointermove', onMove);
        window.addEventListener('pointermove', onMove);

        // file select listener
        addListener(importFile, 'change', async event => {
            const html = await htmlFromFile(event.target.files[0]);
            this.setFromHtml(html);
            importFile.value = "";
        });

        const setElementDragoverDropEffect = (query, effect) => {
            addListener(query, 'dragover', event => {
                killEvent(event);
                event.dataTransfer.dropEffect = this.unlocked ? effect : 'none';
            });
        }

        // dragging and dropping listeners
        setElementDragoverDropEffect(screen, 'copy');
        setElementDragoverDropEffect(this.editorScreen.root, 'none');
        setElementDragoverDropEffect(cardLinkButton, 'move');

        const onDragFromLinkCard = (event) => {
            const cell = this.selectedCardView.card.cell;
            event.dataTransfer.setData('text/uri-list', 'jump:' + coordsToKey(cell));
            event.stopPropagation();
        }

        const onDragFromNewCard = (event) => {
            event.stopPropagation();
            event.dataTransfer.setData('text/plain', 'new card');
        }

        const onDroppedOnDelete = (event) => {
            killEvent(event);
            if (!event.dataTransfer.types.includes('card/move')) return;
            const originJson = event.dataTransfer.getData('card-origin-cell');
            const view = this.cellToView.get(JSON.parse(originJson));
            this.removeCard(view);
        }
        
        setElementDragoverDropEffect(this.addDeleteCardIcon, 'move');
        addListener(this.addDeleteCardIcon, 'dragstart', onDragFromNewCard);
        addListener(this.addDeleteCardIcon, 'drop',      onDroppedOnDelete);
        addListener(this.addDeleteCardIcon, 'pointerdown', event => event.stopPropagation());

        const onDroppedOnCell = async (event) => {
            killEvent(event);
            const dropCell = this.pointerEventToCell(event);
            const dt = event.dataTransfer;

            const image = await dataTransferToImage(event.dataTransfer);
            const urilist = dt.getData('text/uri-list');

            let view;

            if (image) {
                view = this.putImageInCell(dropCell, image);
            } else if (dt.types.includes('card/copy')) {
                const originJson = dt.getData('card-origin-cell');
                const originCell = JSON.parse(originJson);
                const original = this.cellToView.get(originCell).card;
                const copy = JSON.parse(JSON.stringify(original));
                copy.cell = dropCell;
                this.spawnCard(copy);
            } else if (dt.types.includes('card/move')) {
                const originJson = dt.getData('card-origin-cell');
                const originCell = JSON.parse(originJson);
                view = this.swapCells(originCell, dropCell);
            } else if (urilist) {
                const uris = urilist.split('\n').filter(uri => !uri.startsWith('#'));
                const commands = uris.map(uri => uri.startsWith('jump:') ? uri : 'open:' + uri);
                const icons = commands.map(command => { return {icon: 'üîó', command}; });
                view = this.putIconsInCell(dropCell, ...icons);
            } else {
                const text = dt.getData('text') || dt.getData('text/plain');
                if (text)
                view = this.putTextInCell(dropCell, text);
            }

            if (view)
                this.selectCardView(view);
        }

        addListener(cardLinkButton, 'dragstart', onDragFromLinkCard);
        addListener(this.editorScreen.root, 'drop', killEvent);
        addListener(screen,                 'drop', onDroppedOnCell);

        addListener('#coords', 'pointerdown', e => e.stopPropagation());
        addListener('#coords', 'dragstart', event => {
            event.dataTransfer.setData('text/uri-list', 'jump:' + location.hash.slice(1));
            event.stopPropagation();
        });
    }

    setUnlocked(unlocked) {
        this.unlocked = unlocked;

        ALL('[data-locked-visibility]').forEach(element => {
            const hidden = element.getAttribute('data-locked-visibility') === 'hidden';
            element.hidden = (hidden === !unlocked);
        });

        ALL('[data-card]').forEach(element => {
            element.setAttribute('draggable', unlocked ? 'true' : 'false');
        });
    }
    
    deselect() { this.selectCardView(undefined); }

    editStyle() {
        this.aboutScreen.hidden = true;
        ONE('#about-screen').hidden = false;
        this.styleInput.value = ONE('#user-style').innerHTML;
        this.styleInput.focus();
    }

    editFocusedCell() {
        const view = this.getOrSpawnCard(this.focusedCell);
        this.editCardView(view);
    }

    editCardView(view) {
        if (!this.selectCardView) return;
        this.editorScreen.hidden = false;
        this.editorScreen.setActiveView(view);
        this.focusCell(view.cell, this.editorPreview);
    }

    selectCardView(view) {
        this.selectedCardView = view;

        if (view) {
            view.root.appendChild(this.cardbar);
            this.cardbar.hidden = !this.unlocked
        } else if (this.cardbar.parentElement)
            this.cardbar.parentElement.removeChild(this.cardbar);
    }

    onCardPointerDown(view, event) {
        if (!this.unlocked || event.button === 1) return;
        event.stopPropagation();
    }

    onCardClick(view, event) {
        if (!this.unlocked) return;
        killEvent(event);
        this.selectCardView(view);
        this.focusCell(view.cell);
        this.scale = 1;
        this.editFocusedCell();
    }

    onCardDragStart(view, event) {
        if (!this.unlocked) return;

        event.stopPropagation();
        event.dataTransfer.setData('card-origin-cell', JSON.stringify(view.cell));
        event.dataTransfer.setData('text/plain', view.card.text);
        event.dataTransfer.setData(event.ctrlKey ? 'card/copy' : 'card/move', '');

        const [x, y] = getElementCenter(view.root);
        event.dataTransfer.setDragImage(view.root, x, y);
    }

    putImageInCell(cell, image) {
        const view = this.getOrSpawnCard(cell);
        view.card.image = image.dataURL;
        if (image.originURL)
            this.putIconsInCell(cell, {icon: 'üîó', command: 'open:' + image.originURL});
        view.refresh();
        return view;
    }

    putIconsInCell(cell, ...rows) {
        const view = this.getOrSpawnCard(cell);
        view.card.icons = view.card.icons || [];
        for (let i = 0; i < 4; ++i) {
            if (view.card.icons.length === i)
                view.card.icons.push({icon: '', command: ''});
            if (view.card.icons[i].icon === '' && rows.length > 0)
                view.card.icons[i] = rows.shift();
        }
        view.refresh();
        return view;
    }

    putTextInCell(cell, text) {
        const view = this.getOrSpawnCard(cell);
        view.card.text += text;
        view.refresh();
        return view;
    }

    toggleZoom() {
        this.scale = 1.5 - this.scale;
    }
}

class CardEditor {
    constructor() {
        this.root = ONE('#editor-screen');
        this.contentInput = ONE('#content-input', this.root);
        this.typeSelect = ONE('#type-select');
        this.typeButtons = {};

        this.refreshAvailableStyles();

        this.iconRows = [];

        const refreshIcons = () => {
            const icons = [];
            this.iconRows.forEach(row => {
                icons.push({
                    icon: row.select.value,
                    command: row.command.value,
                });
            });
            this.activeView.card.icons = icons;
            this.activeView.refresh();
        }

        for (let row of [1, 2, 3, 4]) {
            const select = ONE(`#editor-icon-select-${row}`, this.root);
            const command = ONE(`#editor-icon-command-${row}`, this.root);
            this.iconRows.push({ select, command });
            addListener(select, 'input', () => refreshIcons());
            addListener(command, 'input', () => refreshIcons());
        }

        this.contentInput.addEventListener('input', () => {
            if (!this.activeView) return;

            this.activeView.card.text = this.contentInput.value;
            this.activeView.refresh();
        });

        this.altTextInput = ONE('#alt-text');
        this.altTextInput.addEventListener('input', () => {
            this.activeView.card.alt = this.altTextInput.value;
            this.refreshFromCard();
        });

        addListener('#remove-image', 'click', () => {
            this.activeView.card.image = undefined;
            this.activeView.refresh();
            this.refreshFromCard();
        });

        addListener('#upload-image', 'click', () => ONE('#upload-image-input').click());
        addListener('#upload-image-input', 'input', async event => {
            this.activeView.card.image = await fileToCompressedImage(event.target.files[0]);
            event.target.value = "";
            this.activeView.refresh();
            this.refreshFromCard();
        });
    }

    get hidden() { return this.root.hidden; }
    set hidden(value) { this.root.hidden = value; }

    refreshAvailableStyles() {
        this.types = findCardStyleNames();
        this.typeSelect.innerHTML = '';

        for (let type of this.types) {
            const button = document.createElement('button');
            button.classList.add('type-button');
            button.innerHTML = type;
            button.setAttribute('title', `change card style to ${type}`);
            this.typeSelect.appendChild(button);

            button.addEventListener('click', () => this.setType(type));
            this.typeButtons[type] = button;
        }
    }

    setActiveView(view) {
        this.activeView = view;
        this.contentInput.select();
        pageSetters.get('card')('text');
        this.refreshFromCard();
    }

    refreshFromCard() {
        if (!this.activeView) return;

        for (let type of this.types)
            this.typeButtons[type].classList.remove('selected');
        this.typeButtons[this.activeView.card.type].classList.add('selected');
        this.contentInput.value = this.activeView.card.text;

        this.iconRows.forEach(row => {
            row.select.value = "";
            row.command.value = "";
        })

        const icons = this.activeView.card.icons || [];
        icons.slice(0, 4).forEach((row, i) => {
            const { select, command } = this.iconRows[i];
            select.value = row.icon
            command.value = row.command;
        });

        ONE('#remove-image').disabled = !this.activeView.card.image;
        this.altTextInput.value = this.activeView.card.alt || "";
    }

    setType(type) {
        if (!this.activeView) return;

        this.activeView.card.type = type;
        this.refreshFromCard();
        this.activeView.refresh();
    }
}

class CardView {
    constructor(card) {
        this._position = [0, 0];
        this._scale = 1;
        this._size = domino.cardSize;
        this.card = card;

        this.root = cloneTemplateElement('#card-template');
        this.text = ONE('.card-text', this.root);
        this.icons = ONE('.icon-bar', this.root);

        Array.from(this.icons.children).forEach((icon, i) => {
            addListener(icon, 'pointerdown', e => e.stopPropagation());
            addListener(icon, 'dblclick', e => e.stopPropagation());
            addListener(icon, 'click', e => { 
                killEvent(e); 
                domino.runCommand(this.card.icons[i].command)
            });
        });

        this.updateContent();
    }

    get cell() { return this.card.cell; }

    set position(value) { 
        this._position = value;
        this.updateTransform();
    }

    set scale(value) { 
        this._scale = value;
        this.updateTransform();
    }

    set transition(value) {
        this.root.classList.toggle('skip-transition', !value);
    }

    skipTransition() {
        this.transition = false;
        reflow(this.root);
        this.transition = true;
    }

    triggerSpawnAnimation() {
        this.transition = false;
        this.root.style.opacity = 0;
        reflow(this.root);
        this.transition = true;
        this.root.style.opacity = 1;
    }

    updateTransform() {
        const [x, y] = this._position;
        const [w, h] = [this.root.offsetWidth, this.root.offsetHeight];

        const position = `translate(${x - w/2}px, ${y - h/2}px)`;
        const scaling = `scale(${this._scale}, ${this._scale})`;
        this.root.style.transform = `${position} ${scaling}`;
    }

    updateContent() {
        for (let type of domino.editorScreen.types)
            this.root.classList.toggle(`domino-card-${type}`, this.card.type === type);

        this.text.innerHTML = parseFakedown(this.card.text);
        this.root.style.setProperty('background-image', this.card.image ? `url(${this.card.image})` : '');
        this.root.classList.toggle('has-image', !!this.card.image);

        (this.card.icons || []).forEach((row, i) => {
            const button = this.icons.children[i];
            button.innerHTML = row.icon;
            button.href = row.command;
            button.classList.toggle('blank', row.icon === '');
            button.classList.toggle('cosmetic', row.command === '');
        });
    }
    
    refresh() {
        this.updateContent();
        this.updateTransform();
    }
}

const domino = new Domino();

async function loaded() {
    setupClassHooks();

    domino.setup();

    window.addEventListener('resize', updateDocumentVariables);
    updateDocumentVariables();

    // no doubleclick on mobile
    DragDropTouch._DBLCLICK = 0;

    // center the currently selected cell
    const jumpFromHash = () => domino.focusCell(getCoordsFromHash());
    window.addEventListener('hashchange', jumpFromHash);
    window.addEventListener('resize', jumpFromHash);
    
    // load data from embeded #data script tag
    const coords = getCoordsFromHash();
    const data = getElementJsonData('#data');
    domino.setUnlocked(false);
    domino.focusCellNoTransition(coords);
    domino.setData(data);

    // image pasting
    window.addEventListener('paste', async event => {
        if (!domino.unlocked) return;
        const image = await dataTransferToImage(event.clipboardData);

        if (image && domino.selectedCardView) {
            const cell = domino.selectedCardView.card.cell;
            domino.putImageInCell(cell, image);
            killEvent(event);
            return;
        }
    });

    // keyboard shortcuts
    window.addEventListener('keydown', event => {
        if (event.key === 'Escape')
            ALL('.screen').forEach(e => e.hidden = true);

        const noScreens = ALL('.screen').map(e => e.hidden).reduce((a, b) => a && b);
        if (!noScreens) return;

        if (event.altKey) {
            if (event.key === 'e') {
                domino.editFocusedCell();
            } else if (event.key === 's') {
                const view = domino.cellToView.get(domino.focusedCell);
                if (view)
                    say((view.card.alt || "") + '.\n' + view.text.innerText);
            }

            killEvent(event);
            return;
        }

        const [q, r] = domino.focusedCell;
        if (event.key === 'ArrowLeft')  domino.focusCell(event.shiftKey ? [q - 1, r + 0] : [q - 1, r + 1]);
        if (event.key === 'ArrowRight') domino.focusCell(event.shiftKey ? [q + 1, r + 0] : [q + 1, r - 1]);
        if (event.key === 'ArrowUp')    domino.focusCell([q + 0, r - 1]);
        if (event.key === 'ArrowDown')  domino.focusCell([q + 0, r + 1]);

        if (event.code === 'KeyQ')  domino.focusCell([q - 1, r + 0]);
        if (event.code === 'KeyW')  domino.focusCell([q + 0, r - 1]);
        if (event.code === 'KeyE')  domino.focusCell([q + 1, r - 1]);
        if (event.code === 'KeyA')  domino.focusCell([q - 1, r + 1]);
        if (event.code === 'KeyS')  domino.focusCell([q + 0, r + 1]);
        if (event.code === 'KeyD')  domino.focusCell([q + 1, r + 0]);

        if (event.key === ' ') domino.toggleZoom();
    });

    window.addEventListener('wheel', event => {
        if (event.deltaY > 0) domino.scale = .5;
        if (event.deltaY < 0 && domino.scale === .5) {
            domino.deselect();
            domino.focusCell(domino.pointerEventToCell(event));
            domino.scale = 1;
        }
    });

    // neocities publish
    const startButton = document.querySelector("#neocities-start");
    const openButton = document.querySelector("#neocities-open");

    startButton.addEventListener("click", async () => {
        console.log("HELLO")
        openButton.hidden = false;
        openButton.disabled = true;

        const ready = new Promise((resolve, reject) => {
            const remove = listen(window, "message", (event) => {
                if (event.origin !== "https://kool.tools") return;
                remove();
                resolve();
            });
        });

        const success = new Promise((resolve, reject) => {
            const remove = listen(window, "message", (event) => {
                if (event.origin !== "https://kool.tools") return;

                if (event.data.error) {
                    remove();
                    reject(event.data.error);
                } else if (event.data.url) {
                    remove();
                    resolve(event.data.url);
                }
            });
        });

        const popup = window.open(
            "https://kool.tools/neocities-publisher/index.html", 
            "neocities publisher",
            "left=10,top=10,width=320,height=320");
        const { name, html } = projectToHTML();
        await ready;
        popup.postMessage({ name, html }, "https://kool.tools");
        const url = await success;
        popup.close();
        openButton.disabled = false;
        openButton.onclick = () => window.open(url);
    });
}

    </script>
  </head>
  <body class="no-select" onload="loaded()">
    <div id="templates" hidden="">
      <div class="card" id="card-template" draggable="false" data-card="">
        <div class="card-text"></div>
        <div class="card-icon-bar icon-bar"><a class="blank"></a><a class="blank"></a><a class="blank"></a><a class="blank"></a></div>
      </div>
      <div class="card-edit-bar icon-bar" id="cardbar-template" data-locked-visibility="hidden" hidden="">
        <button id="edit-card" title="edit this card">üìù</button>
        <button id="link-card" title="link this card" draggable="true" hidden="">üîó</button>
      </div>
    </div>
    <div id="pan-screen">
      <main id="scene" data-export-clear="" class="" style="transform: scale(1) translate(-598px, -1331px);"></main>
    </div>
    <div id="coords" draggable="true">#2,6</div>
    <div class="icon-bar" id="toolbar" data-block-clicks="">
      <div id="open-about" title="information &amp; settings">üî®</div>
      <div id="zoom" title="switch zoom level">üîé</div>
      <div id="center" title="jump to center">üè†</div>
      <div id="add-delete-icon" draggable="true" title="drag a new card from here or a drop an unwanted card" data-locked-visibility="hidden" hidden="">üóÉÔ∏è</div>
      <div id="fullscreen" title="toggle fullscreen" hidden="">üí¢</div>
      <div id="unlocked" title="prevent accidental editing" data-locked-visibility="hidden" hidden="">üîì</div>
      <div id="locked" title="enable editing" data-locked-visibility="shown">üîí</div>
    </div>
    <div id="pan-blocker" hidden=""></div>
    <div class="screen" id="display-screen" data-click-to-hide="" hidden="">
      <iframe id="display-frame" data-block-clicks="" allow="autoplay"></iframe>
    </div>
    <div class="screen" id="editor-screen" data-click-to-hide="" hidden="">
      <div id="editor-preview"></div>
      <div id="editor-section" data-block-clicks="">
        <div class="tab-bar">
          <div data-close-parent-screen="">‚óÄ </div>
          <div class="selected" data-tab="text" data-tab-set="card">TEXT</div>
          <div data-tab="icons" data-tab-set="card" class="">ICONS</div>
          <div data-tab="style" data-tab-set="card" class="">STYLE</div>
        </div>
        <div class="editor-page tab-page" data-page="text" data-tab-set="card">
          <textarea id="content-input"></textarea>
        </div>
        <div class="editor-page tab-page" data-page="icons" data-tab-set="card" hidden="">
          <input class="icon-select" id="editor-icon-select-1" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-command" id="editor-icon-command-1" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-select" id="editor-icon-select-2" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-command" id="editor-icon-command-2" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-select" id="editor-icon-select-3" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-command" id="editor-icon-command-3" type="text" data-com.bitwarden.browser.user-edited="yes">
          <input class="icon-select" id="editor-icon-select-4" type="text">
          <input class="icon-command" id="editor-icon-command-4" type="text">
        </div>
        <div class="editor-page" data-page="style" data-tab-set="card" hidden="">
          <div class="button-list" id="type-select" data-export-clear=""></div>
          <div class="button-list">
            <button id="upload-image">upload image</button>
          </div>
          <div class="button-list">
            <input id="alt-text" type="text" placeholder="alt text">
            <button id="remove-image" disabled="">remove image</button>
            <input id="upload-image-input" type="file" accept="image/*" data-com.bitwarden.browser.user-edited="yes" hidden="">
          </div>
        </div>
      </div>
    </div>
    <div class="screen" id="menu-screen" data-click-to-hide="" data-export-hide="" hidden="">
      <div class="full-panel" data-block-clicks="">
        <div class="tab-bar" data-tab="">
          <div data-close-parent-screen="">‚óÄ </div>
          <div class="" data-tab="howto" data-tab-set="menu">HOWTO</div>
          <div data-tab="board" data-tab-set="menu" class="selected">BOARD</div>
          <div data-tab="about" data-tab-set="menu" class="">ABOUT</div>
        </div>
        <div class="tab-page" data-page="board" data-tab-set="menu">
          <h3>board title</h3>
          <input id="board-title" data-com.bitwarden.browser.user-edited="yes">
          <h3>actions</h3>
          <div class="button-list">
            <button id="import" title="import a domino project">üìÇ import from html</button>
            <button id="export" title="export as html">üì¶ export to html</button>
            <button id="neocities-start" title="begin neocities publish">üòª publish to neocities</button>
            <button id="neocities-open" data-export-hide="" title="open published neocities" hidden="">üëÄ open neocities page</button>
            <button id="reset" title="remove all cards">‚ùå remove all cards</button>
          </div>
          <input id="import-file" type="file" accept=".html" hidden="">
          <h3>style</h3>
          <textarea id="style-input"></textarea>
        </div>
        <div class="tab-page" data-page="howto" data-tab-set="menu" hidden=""><h2>what is this</h2>
<p>this page was created using a tool called <a href="https://kool.tools/domino/">domino</a>. it is a spatial
arrangement of cards that together might form an essay or a mind map or a
collage or something else entirely.</p>
<p>click and drag to navigate the board. double click a card to jump to it. some
cards have emoji icons along the bottom that perform various actions when
clicked.</p>
<p>this page is also a working copy of domino. toggle into unlocked mode with
the üîì icon on the toolbar, and made your own changes.</p>
<h2>keyboard shortcuts</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>arrows</strong></td>
<td>move between cards</td>
</tr>
<tr>
<td><strong>QWEASD</strong></td>
<td>move between cards</td>
</tr>
<tr>
<td><strong>escape</strong></td>
<td>exit window</td>
</tr>
<tr>
<td><strong>alt+s</strong></td>
<td>speak selected card</td>
</tr>
<tr>
<td><strong>alt+e</strong></td>
<td>edit selected card</td>
</tr>
<tr>
<td><strong>ctrl+drag</strong></td>
<td>make copy of card</td>
</tr>
</tbody>
</table>

        </div>
        <div class="tab-page" data-page="about" data-tab-set="menu" hidden="">
          <div id="version">
            version‚Äîbeta-7 (11/5/2020)</div><h2>about domino</h2>
<p>domino is a tool for collaging fragmented thoughts into a larger idea.
it's essentially a tool for making a particular kind of mindmap and sharing it
as a page on your website or itch.io.</p>
<p>you can find out more about domino on <a href="https://kool.tools/domino/">the release page</a>. the source
code for original releases can be found <a href="https://github.com/Ragzouken/domino">on github</a>.</p>
<p>i'm <a href="https://twitter.com/ragzouken">mark wonnacott a.k.a candle</a> and i created domino as a
<a href="https://kool.tools/2020/02/26/speculations.html">response to my frustration</a> trying to express myself in Emilie Reed's
writing jams.</p>
<h2>thanks</h2>
<p><strong>Em Reed</strong> for <a href="https://itch.io/jam/manifesto-jam">Manifesto Jam</a> and <a href="https://itch.io/jam/speculation-jam">Speculation Jam</a> which have
deeply inspired me and also motivated the creation of this tool. also for
certain flippant comments that pushed me into developing web based tools.</p>
<p><strong>Max</strong> for <a href="https://github.com/synth-ruiner/image-to-bitsy">image to bitsy</a> whose source code was a valuable reference for
developing web tools. also for feedback and bug reports.</p>
<p><strong>sg</strong> for <a href="https://zenzoa.itch.io/mosi">m√¥si</a> whose source code was a valuable reference for developing
web tools. also for feedback and bug reports.</p>
<p><strong>Kris De Decker</strong> for <a href="https://solar.lowtechmagazine.com/">LOW‚ÜêTECH MAGAZINE</a> which continues to inspire me to
think about how computing and software can and must change in the future. also
the aesthetic inspiration for the default style in domino.</p>
<p><strong>Chris Klimas</strong> for <a href="https://twinery.org/">Twine</a> whose card based layout and ecosystem of user
customisation is an inspiration to domino.</p>
<h2>attribution</h2>
<p><strong>Bernardo Castilho</strong> created <a href="https://github.com/Bernardo-Castilho/dragdroptouch">DragDropTouch</a> which domino uses to make card
dragging work correctly in mobile browsers.</p>
<p><strong>Eli Grey</strong> created <a href="https://github.com/eligrey/FileSaver.js/">FileSaver.js</a> which domino uses to launch the save
dialogue when exporting.</p>
<p><strong>Cyreal</strong> created <a href="https://fonts.google.com/specimen/Lora">Lora</a> which is the font domino uses.</p>

        </div>
      </div>
    </div>
    <div class="screen" id="load-screen" data-block-clicks="" hidden=""></div>
  
<!-- Code injected by live-server -->
<script type="text/javascript">
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script><!-- Code injected by live-server -->
<script type="text/javascript">
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script><!-- Code injected by live-server -->
<script type="text/javascript">
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script><!-- Code injected by live-server -->
<script type="text/javascript">
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script></body></html>